# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gCq18R2ueepWFB45VlUpoEf_IB5gOSqi
"""

pip install streamlit

pip install fuzzywuzzy

import streamlit as st
import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from fuzzywuzzy import process

# Set page configuration
st.set_page_config(page_title="Hindi Songs Recommender", page_icon="ðŸŽµ", layout="wide")

# Title and description
st.title("ðŸŽµ Hindi Songs Recommendation System")
st.markdown("""
Enter a song, artist, or album to get personalized Hindi song recommendations. Optionally, filter by genre to narrow down your results.
""")

# Load Data
@st.cache_data
def load_data():
    df = pd.read_csv("hindi_songs.csv")
    df.rename(columns={
        'Track Name': 'track_name',
        'Artist Name': 'artist_name',
        'Track URI': 'spotify_link',
        'Album': 'album',
        'Duration (ms)': 'duration'
    }, inplace=True)
    return df

df = load_data()

# Preprocessing
df1 = df[['track_name', 'artist_name', 'spotify_link', 'album', 'duration', 'Artist Genres']]
df1 = df1.drop_duplicates(subset=['track_name', 'artist_name', 'album']).reset_index(drop=True)

# Fill NaN values
df1['track_name'] = df1['track_name'].fillna("")
df1['artist_name'] = df1['artist_name'].fillna("")
df1['album'] = df1['album'].fillna("")
df1['Artist Genres'] = df1['Artist Genres'].fillna("")

# Format Spotify Links
df1['spotify_link'] = df1['spotify_link'].apply(lambda x: f"https://open.spotify.com/track/{x.split(':')[-1]}")

# Duration formatting
df1['formatted_duration'] = df1['duration'].apply(lambda x: f"{int(x // 60000)}:{int((x % 60000) / 1000):02d}")

# Add Genre based on album name and artist genres
def infer_genre(row):
    album_name = row['album'].lower()
    artist_genres = row['Artist Genres'].lower()

    # Check Artist Genres first
    if 'chutney' in artist_genres:
        return 'Chutney'
    if 'filmi' in artist_genres:
        return 'Filmi'
    if 'bhajan' in artist_genres or 'ghazal' in artist_genres or 'sufi' in artist_genres or 'hare krishna' in artist_genres:
        return 'Bhajan'
    if 'bhojpuri pop' in artist_genres:
        return 'Bhojpuri'
    if 'afghan pop' in artist_genres:
        return 'Afghan'
    if 'classic bollywood' in artist_genres or 'classic pakistani pop' in artist_genres or 'classic punjabi pop' in artist_genres:
        return 'Classic'

    # Infer from album name
    if 'bhajan' in album_name or 'devotional' in album_name or 'krishna' in album_name:
        return 'Bhajan'
    elif 'bhojpuri' in album_name:
        return 'Bhojpuri'
    elif 'classic' in album_name or 'evergreen' in album_name or 'retro' in album_name:
        return 'Classic'
    elif 'afghan' in album_name or 'pashto' in album_name:
        return 'Afghan'
    else:
        return 'Filmi'

df1['genre'] = df1.apply(infer_genre, axis=1)

# TF-IDF Vectorization
@st.cache_resource
def train_tfidf():
    tfidf = TfidfVectorizer()
    combined_data = df1['track_name'] + ' ' + df1['artist_name'] + ' ' + df1['album']
    vectorizer = tfidf.fit_transform(combined_data)
    return tfidf, vectorizer

tfidf, vectorizer = train_tfidf()

# Recommendation Function
def get_recommendations(user_input, tfidf, vectorizer, df, num_recommendations=10, genre_filter=None):
    all_choices = df['track_name'].tolist() + df['artist_name'].tolist() + df['album'].tolist()
    best_matches = process.extract(user_input, all_choices, limit=5)
    best_matches = [match for match in best_matches if match[1] >= 70]

    if not best_matches:
        return pd.DataFrame(), "No close matches found. Please check your input."

    combined_query = ' '.join([match[0] for match in best_matches])
    user_vector = tfidf.transform([combined_query])
    user_similarity = cosine_similarity(user_vector, vectorizer)
    similar_indices = user_similarity.argsort()[0][-num_recommendations:][::-1]

    recommendations = df.iloc[similar_indices][['track_name', 'artist_name', 'album', 'formatted_duration', 'spotify_link', 'genre']]
    if genre_filter:
        recommendations = recommendations[recommendations['genre'] == genre_filter]

    return recommendations, None

# User Input Form
with st.form("recommendation_form"):
    user_input = st.text_input("Enter a song, artist, or album", placeholder="e.g., Lata Mangeshkar, Chand Sifarish")
    user_genre = st.selectbox("Optional - Select genre", [""] + ["Bhajan", "Bhojpuri", "Classic", "Chutney", "Filmi", "Afghan"], index=0)
    submit_button = st.form_submit_button("Get Recommendations")

# Display Recommendations
if submit_button and user_input:
    with st.spinner("Generating recommendations..."):
        recommendations, error = get_recommendations(user_input, tfidf, vectorizer, df1, num_recommendations=10, genre_filter=user_genre if user_genre else None)

    if error:
        st.error(error)
    elif not recommendations.empty:
        st.subheader("Recommended Songs")
        recommendations['spotify_link'] = recommendations['spotify_link'].apply(lambda x: f'<a href="{x}" target="_blank">Listen on Spotify</a>')
        st.write(recommendations[['track_name', 'artist_name', 'album', 'formatted_duration', 'genre', 'spotify_link']].to_html(escape=False, index=False), unsafe_allow_html=True)
    else:
        st.warning(f"No recommendations found for '{user_input}' with genre '{user_genre}'.")
else:
    st.info("Enter a song, artist, or album and optionally select a genre to get recommendations.")