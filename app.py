# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1F7p6SWM6Yi9lUgu60YuG9_qoH-9TSE-c
"""

!pip install thefuzz

pip install streamlit

pip install fuzzywuzzy

from fuzzywuzzy import process
import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from fuzzywuzzy import process

df = pd.read_csv("hindi_songs.csv")
df.rename(columns={
    'Track Name': 'track_name',
    'Artist Name': 'artist_name',
    'Track URI': 'spotify_link',
    'Album': 'album',
    'Duration (ms)': 'duration'
}, inplace=True)

df1 = df[['track_name', 'artist_name', 'spotify_link', 'album', 'duration']]
df1.drop_duplicates(subset=['track_name', 'artist_name', 'album'], inplace=True)
df1.reset_index(drop=True, inplace=True)

# Fill NaN values
df1['track_name'].fillna("", inplace=True)
df1['artist_name'].fillna("", inplace=True)
df1['album'].fillna("", inplace=True)

# Format Spotify Links
df1['spotify_link'] = df1['spotify_link'].apply(lambda x: f"https://open.spotify.com/track/{x.split(':')[-1]}")

# Duration formatting
df1['formatted_duration'] = df1['duration'].apply(lambda x: f"{int(x // 60000)}:{int((x % 60000) / 1000):02d}")

def infer_genre_from_album(album_name):
    album_name = album_name.lower()
    if 'love' in album_name or 'romantic' in album_name:
        return 'Romantic'
    elif 'bhojpuri' in album_name or 'bhojpuri' in album_name:
        return 'bhojpuri'
    elif 'bhajan' in album_name or 'bhajan' in album_name:
        return 'bhajan'
    elif 'classic' in album_name:
        return 'Classic'
    else:
        return 'Pop'

df1['genre'] = df1['album'].apply(infer_genre_from_album)

# TF-IDF Vectorization
tfidf = TfidfVectorizer()
combined_data = df1['track_name'] + ' ' + df1['artist_name'] + ' ' + df1['album']
vectorizer = tfidf.fit_transform(combined_data)

def get_recommendations(user_input, tfidf, vectorizer, df, num_recommendations=10, genre_filter=None):

    # All possible choices to match user input
    all_choices = df['track_name'].tolist() + df['artist_name'].tolist() + df['album'].tolist()

    # Get best matches using fuzzywuzzy
    best_matches = process.extract(user_input, all_choices, limit=5)

    # Filter matches manually based on score
    best_matches = [match for match in best_matches if match[1] >= 70]  # Keep matches with a score of 70 or higher

    if not best_matches:
        print("No close matches found. Please check your input.")
        return pd.DataFrame()

    # Combine top matches into one query
    combined_query = ' '.join([match[0] for match in best_matches])

    # Transform user input into vector
    user_vector = tfidf.transform([combined_query])
    user_similarity = cosine_similarity(user_vector, vectorizer)

    # Get indices of most similar songs
    similar_indices = user_similarity.argsort()[0][-num_recommendations:][::-1]

    recommendations = df.iloc[similar_indices][['track_name', 'artist_name', 'album', 'formatted_duration', 'spotify_link', 'genre']]

    # Apply genre filter if provided
    if genre_filter:
        recommendations = recommendations[recommendations['genre'] == genre_filter]

    return recommendations

user_input = input("Enter a song, artist, or album: ")
user_genre = input("Optional - Enter genre (Romantic, Dance, Rock, Classical, Pop) or press Enter to skip: ").capitalize()

# Get recommendations with genre filter if provided
recommendations = get_recommendations(user_input, tfidf, vectorizer, df1, num_recommendations=10, genre_filter=user_genre)

# Output the recommendations
if not recommendations.empty:
    print("\nRecommended Songs:")
    print(recommendations.to_string(index=False))  # Display results without index
else:
    print("No recommendations found.")

import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from fuzzywuzzy import process

# Load Data
df = pd.read_csv("hindi_songs.csv")
df.rename(columns={
    'Track Name': 'track_name',
    'Artist Name': 'artist_name',
    'Track URI': 'spotify_link',
    'Album': 'album',
    'Duration (ms)': 'duration'
}, inplace=True)

# Preprocessing
df1 = df[['track_name', 'artist_name', 'spotify_link', 'album', 'duration']]
df1.drop_duplicates(subset=['track_name', 'artist_name', 'album'], inplace=True)
df1.reset_index(drop=True, inplace=True)

# Fill NaN values
df1['track_name'].fillna("", inplace=True)
df1['artist_name'].fillna("", inplace=True)
df1['album'].fillna("", inplace=True)

# Format Spotify Links
df1['spotify_link'] = df1['spotify_link'].apply(lambda x: f"https://open.spotify.com/track/{x.split(':')[-1]}")

# Duration formatting
df1['formatted_duration'] = df1['duration'].apply(lambda x: f"{int(x // 60000)}:{int((x % 60000) / 1000):02d}")

# Add Genre based on album name
def infer_genre_from_album(album_name):
    album_name = album_name.lower()
    if 'love' in album_name or 'romantic' in album_name:
        return 'Romantic'
    elif 'dance' in album_name or 'party' in album_name:
        return 'Dance'
    elif 'rock' in album_name or 'guitar' in album_name:
        return 'Rock'
    elif 'classical' in album_name:
        return 'Classical'
    else:
        return 'Pop'

df1['genre'] = df1['album'].apply(infer_genre_from_album)

# TF-IDF Vectorization
tfidf = TfidfVectorizer()
combined_data = df1['track_name'] + ' ' + df1['artist_name'] + ' ' + df1['album']
vectorizer = tfidf.fit_transform(combined_data)

# Recommendation Function with Genre Filter
def get_recommendations(user_input, tfidf, vectorizer, df, num_recommendations=10, genre_filter=None):

    # All possible choices to match user input
    all_choices = df['track_name'].tolist() + df['artist_name'].tolist() + df['album'].tolist()

    # Get best matches using fuzzywuzzy
    best_matches = process.extract(user_input, all_choices, limit=5)

    # Filter matches manually based on score
    best_matches = [match for match in best_matches if match[1] >= 70]  # Keep matches with a score of 70 or higher

    if not best_matches:
        print("No close matches found. Please check your input.")
        return pd.DataFrame()

    # Combine top matches into one query
    combined_query = ' '.join([match[0] for match in best_matches])

    # Transform user input into vector
    user_vector = tfidf.transform([combined_query])
    user_similarity = cosine_similarity(user_vector, vectorizer)

    # Get indices of most similar songs
    similar_indices = user_similarity.argsort()[0][-num_recommendations:][::-1]

    recommendations = df.iloc[similar_indices][['track_name', 'artist_name', 'album', 'formatted_duration', 'spotify_link', 'genre']]

    # Apply genre filter if provided
    if genre_filter:
        recommendations = recommendations[recommendations['genre'] == genre_filter]

    return recommendations

# User Input
user_input = input("Enter a song, artist, or album: ")
user_genre = input("Optional - Enter genre (Romantic, Dance, Rock, Classical, Pop) or press Enter to skip: ").capitalize()

# Get recommendations with genre filter if provided
recommendations = get_recommendations(user_input, tfidf, vectorizer, df1, num_recommendations=10, genre_filter=user_genre)

# Output the recommendations
if not recommendations.empty:
    print("\nRecommended Songs:")
    print(recommendations.to_string(index=False))  # Display results without index
else:
    print("No recommendations found.")

